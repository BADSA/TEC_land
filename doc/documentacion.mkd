# Introducción

El proyecto consiste en realizar una reimplementación de algunas de las funciones de varias capas del modelo OSI, generando un protocolo propio para el 
envio de mensajes a través de la red y definiendo un RFC para el mismo.

### Capa 1: Medio Físico
En el proyecto el medio físico por utilizar es la luz. Para su transmisión de hará uso de una Raspberry Pi, un LED, un receptor de luz, un capacitor, entre otros.
El objetivo es convertir los paquetes en presencia o ausencia de luz, e interpretar estas señales en el otro extremo pudiendo reconstruir el paquete y darle el sentido
con el que se envio.

### Capa 2 y 3: TEC-land
Consiste en una red que funciona sobre TCP/IP mediante la cual se realiza el envio de mensajes de texto de un nodo a otro. 
Los diferentes nodos centrales se encargan de realizar el ruteo de los paquetes a través de los distintos dispositivos que se encuentran asociados

### Capa 4: Aplicación
El propósito de TEC-land es ser una red de chat que permita la comunicación entre personas en distintas localizaciones. Esto se da a nivel
interno de la red, permitiendo que las comunicaciones sean privadas. Existe también la opción de enviar mensajes que salgan a la "clearnet" y sean
accesibles por todo el público, como también se pueden mandar "broadcast" a lo interno de la red.

Además en esta capa se debe realizar la instalación de un servidor IRC, para que los mensajes catalogados como públicos pueden ser vistos por las personas.
Asimismo se debe brindar la posibilidad de publicar entradas en un servidor de nntp.

# Ambiente de desarrollo

Indicar las herramientas usadas para implementar la tarea.

Python: es un lenguaje de programación interpretado cuya filosofía hace hincapié en una sintaxis que favorezca un código legible. Se trata de un lenguaje de programación multiparadigma, ya que soporta orientación a objetos, programación imperativa y, en menor medida, programación funcional. Es un lenguaje interpretado, usa tipado dinámico y es multiplataforma.

Twisted: es un framework de red para programación dirigida por eventos escrito en Python y licenciado bajo la licencia MIT. Twisted proporciona soporte para varias arquitecturas (TCP, UDP, SSL/TLS, IP Multicast, Unix domain sockets), un gran número de protocolos (incluidos HTTP, XMPP, NNTP, IMAP, SSH, IRC, FTP), y mucho más.

PyCharm: es un entorno de desarrollo integrado (IDE) que se utiliza para la programación en Python. Proporciona análisis de código, un depurador gráfico, un medidor de unidad integrada, integración con sistemas de control de versiones (prensas de tornillo), y apoya el desarrollo web con Django. PyCharm es desarrollado por la empresa checa JetBrains.



# Estructuras de datos usadas y funciones

### Principales estructuras utilizadas

**Listas**: utilizadas para almacenar los routers bien conocidos utilizados por un host para establecer conexion o por otro router cuando se necesita transmitir algun paquete a un nodo que no se encuentra entre sus conexiones directas.

**Diccionarios**: utilizados principalmente para la transmisión de mensajes. Se envian objetos Diccionario que consisten de diferentes llaves y valores, estos permiten a los host y router categorizar los mensajes y distinguir entre la función que cada uno de estos tiene. Por ejemplo se tiene los tipos "m", "r", "q", "fw", que permiten respectivamente enviar un mensaje a otro usuario, registrar a un usuario dentro de la red, hacer una consulta a los demás routers para el balance de conexiones y hacer "forward" de un mensaje a un usuario conectado directamente a un router.

### Principales funciones

```ConnectionFinder::look_for_router()```

```Host::send(msg)```

```ChatClient::dataReceived(data)```

```HostManager::exists(username)```

```HostManager::register(host)```

```HostManager::delete(username)```

```HostManager::get_users()```

```RouterConnection::connectionMade()```

```RouterConnection::dataReceived(data)```

```RouterConnection::parse_data(data)```

```RouterConnection::```



# Instrucciones para ejecutar el programa

Presentar las consultas concretas usadas para correr el programa para el problema planteado en el enunciado de la tarea y para los casos planteados al final de esta documentacion.

Para correr TEC-land se tienen 2 archivos principales:

host/main.py: se encarga de correr la aplicación host en un nodo. Este tiene como funciones principales la recepción y el envío de mensajes a travéz de la red.

router/router.py: archivo principal de los nodos centrales, también llamados routers, que permite a estos ponerse disponibles y empezar a funcionar como punto de enlace para los siguientes host que se integren a la red. Este es el que se encarga de realizar todas las operaciones de ruteo en la red.

Ambas aplicaciones deben ser un cliente y un servidor al mismo tiempo y para ejecutarlas simplemente se ejecuta el comando:

``` $ python2 main.py``` o ```$ python2 router.py```

Y se digita la información requerida para su inicio.



# Actividades realizadas por el estudiante

Este es un resumen de las bitacoras de cada estudiante ( estilo timesheet) en t ́erminos del tiempo invertido para una actividad espec ́ıfica que impacto directamente el desarrollo del trabajo, de manera breve (no mas de una l ́ınea) se describe lo que se realizo, la cantidad de horas invertidas y la fecha en la que se realizo. Se deben sumar las horas invertidas por cada estudiante, sean conscientes a la hora de realizar esto el profesor determinara si los reportes estan acordes al producto entregado.

Jueves 14 de abril 
- Trabajamos en el Host:
    - Envio de mensaje hasta router para que este se encargue de hacerle "forward".
    - Creacion de "thread" para que muestre el chat preguntando a quien va dirigido el mensaje
    y su contenido.
    - Clases ChatClient, HostFactory,


De jueves a viernes 01 de abril
- Lectura de la especificación.
- Reunión con el profesor para aclarar puntos de la tarea.
- Investigacion de P2P, APIs para redes mesh en Python, servidores IRC (Unreal IRC) y clientes (XChat IRC), Firechat
- Logramos encender el LED de la Raspberry.

11/04
- Creación del repositorio.
- Investigacion de Twisted.
    -  Lectura de creacion de clientes y servidores básicos.
- Creación de la clase HostManager.
    - Encargada de administrar los host conectados a cada Router.
- Estructura de la clase Router.
- Agregando estructuras para cliente y servidor.
    - Clases Protocol y Factory para realizar el listenTCP y el connectTCP.

12/04
- Separacion de clase Router en dos clases Router y RouterConnection.
    - RouterConnection registra los usuarios.
- Investigación sobre objetos Diferred de Twisted.
- Nueva estructura de los componentes del proyecto.
- Creación de clase ConnectionFinder para revisar la lista de routers bien conocidos y establecer contacto con alguno con el fin de obtener la ip y el puerto del router con el cuál establecer la conexión.

14/04
- Consultar a los router vecinos para realizar el balanceamiento de carga (asignar host al menos cargado).
    - Se trabajó en la comunicación entre los router.
- Creación de clase SocketCliente para manejar las conexiones cliente-servidor y realizar envío de mensajes.
    - Encapsula las funciones de conectar y enviar mensajes.
- Trabajo para realizar envío de mensajes desde el servidor, utilizando el Protocol.
    - Como el Reactor de Twisted trabajo por eventos, en el Protocol y Factory los métodos se rigen de esa manera, por lo que para enviar un mensaje era necesario crear un método que se comportara como un evento. Tras investigar en la documentación de Twisted nos dimos cuenta de 2 alternativas. Una era añadir un callback al reactor para que ejecutará un método tras cierto tiempo. Sin embargo esto únicamente se realizaba una vez. La otra manera era mediante LoopingCall(task) por medio del cual se establece que se ejecute una tarea cada cierto tiempo. Sin embargo tras varios intentos no se logro que esto funcionará en la clase Protocol ni en la clase Factory del servidor, por lo que se optó por manejar este envío por medio de Sockets.
    - Creación de clase host, para envio de mensajes.

15/04
- Modificaciones en la clase HostManager.
- Verificación de usuarios en toda la red.
- Redireccionamiento de mensajes cuando no se encuentra el usuario en la red local.
- Creación de clase ChatClient.
- Agregación de un atributo status en los mensajes para notificar al usuario (host) el estado de la petición.
- Creación del archivo MarkDown para la documentación, creación de las diferentes secciones y trabajo en la Introducción, Herramientas Usadas y Bitácora.

16/04
- Modificación de la clase RouterConnection para realizar broadcast de un mensaje a la red (se modificaron algunos parámetros).
- Documentación parcial de código.

Martes 05 de abril
- Implementacion del modelo de datos en Python.
- Investigacion de Scapy.
- Llenando el archivo yaml con los servidores conocidos.
- Creando clases para los distintos tipos de servidores.
- Investigacion de chat servers/clients con la biblioteca de select en Python.
- Decisiones para usuarios y subredes en el protocolo.

Sabado 09 de abril
- Investigacion de IRC Servers y Clients con Twisted
- Instalacion de Unrealircd
    - Descarga https://www.unrealircd.org/unrealircd4/unrealircd-4.0.2.tar.gz
    - Lo descomprime y entra a la carpeta descomprimida
    - Desde consola (dentro de la carpeta):
        - ./Config
        - Luego se presiona Enter
        - Sale una parte de Notas, con Spacebar baja
        - Cuando termina vuelve a presionar Enter
        - Enter otra vez.
        - Directorio donde se quiere instalar (enter si ya esta ahi)
        - Enter (permisos se dejan en default)
        - Enter
        - No (En la imagen aparece con Yes, pero despues tuve que cambiarlo a No)
        - No en ambas opciones
        - Enter
        - Asegurese tener gcc actualizado porque a mi me dio error el primer intento
        - Cuando termina de instalar, salen preguntas
        - Yo cree un certificado por varas
        - Si no quiere crearlo dele No.
        - Luego hace make
        - make install
        - Ir al directorio donde instalo unrealircd
        - Copie example.conf de unrealircd/conf/examples/ a unrealircd/conf/ y le cambia el nombre a
        unrealircd.conf
        - Abra el unrealircd.conf
        - Lo primero queda igual
        - Cambia el Me y Admin
        - Cambia el bloque de oper
        - Cambia los cloak-keys, los puede generar con ./unrealircd gencloak
        - Cambia el kline-address por un correo o URL
        - El resto queda igual
        - Lo guarda
        -

Domingo 10 de abril
- Debugeando instalacion unrealircd
- Probando servidor y cliente TCP de twisted

Lunes 11 de abril
- Programando un server-client TCP, ya funciona.
- Diseñando la red y como conectar nodos (usuario y registrador).
- Implementando configManager para manejar yaml.
- Implementando el cliente con sockets.
- Trabajando clase RegistryNode
- Clase UserNode
- Ya funciona el paso de mensajes; se pueden registrar, agregar vecinos, chequear si existe usuario y anular registro.
- Comentando secciones de código.

Martes 12 de abril:
- Implementando el chat (preguntar por mensajes y envío a través de red).
- Clase prompt printer para impresión de mensajes en consola.
- Clase msg processor para manejar los strings ingresados por el usuario.
- Funcionalidad de envío de mensajes a vecinos directos funcionando.
- Validación de los mensajes ingresados por el usuario.
- Envío de mensajes dentro de toda la comarca funcionando. Resiste errores cuando algun nodo se desconecta.

Miércoles 13 de abril:
- Trabajo en RFC basado en el de HTTP/1.1

Jueves 14 de abril:
- Terminando RFC.
- Trabajo en la clase de gatewayNode.



# Comentarios finales
Indicar el estado final en que qued ́o el programa, problemas encontrados y limitaciones adicionales.

# Conclusiones

# Bibliografía